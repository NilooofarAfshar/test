// ======================================================
// FILE: src/main.ts
// ======================================================
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { appConfig } from './app/app.config';

bootstrapApplication(AppComponent, appConfig).catch(console.error);

// ======================================================
// FILE: src/app/app.config.ts
// ======================================================
import { ApplicationConfig } from '@angular/core';
import { PreloadAllModules, provideRouter, withPreloading } from '@angular/router';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { routes } from './app.routes';
import { errorInterceptor } from './core/http/error.interceptor';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes, withPreloading(PreloadAllModules)),
    provideHttpClient(withInterceptors([errorInterceptor])),
  ],
};

// ======================================================
// FILE: src/app/app.routes.ts
// ======================================================
import { Routes } from '@angular/router';

export const routes: Routes = [
  { path: '', pathMatch: 'full', redirectTo: 'files' },
  {
    path: 'files',
    loadChildren: () =>
      import('./features/files/files.routes').then((m) => m.FILES_ROUTES),
  },
  {
    path: '**',
    loadComponent: () =>
      import('./shared/not-found.page').then((m) => m.NotFoundPage),
  },
];

// ======================================================
// FILE: src/app/app.component.ts
// ======================================================
import { Component } from '@angular/core';
import { RouterOutlet } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet],
  template: `
    <header class="shell">
      <h1>File Drive</h1>
      <nav>
        <a routerLink="/files">Files</a>
      </nav>
    </header>
    <main class="container">
      <router-outlet></router-outlet>
    </main>
  `,
  styles: [
    `
      .shell {
        display: flex;
        gap: 1rem;
        align-items: center;
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #eee;
      }
      .container {
        padding: 1rem;
        max-width: 960px;
        margin: 0 auto;
      }
      a {
        text-decoration: none;
      }
    `,
  ],
})
export class AppComponent {}

// ======================================================
// FILE: src/app/core/http/error.interceptor.ts
// ======================================================
import { HttpInterceptorFn } from '@angular/common/http';
import { catchError } from 'rxjs/operators';
import { throwError } from 'rxjs';
import { inject } from '@angular/core';
import { Telemetry } from '../obs/telemetry.service';

export const errorInterceptor: HttpInterceptorFn = (req, next) => {
  const tel = inject(Telemetry);
  return next(req).pipe(
    catchError((err) => {
      tel.track('http_error', {
        url: req.url,
        method: req.method,
        status: err?.status,
      });
      return throwError(() => err);
    })
  );
};

// ======================================================
// FILE: src/app/core/obs/telemetry.service.ts
// ======================================================
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class Telemetry {
  track(event: string, props?: Record<string, unknown>) {
    // اینجا به Sentry/OTel/LogServer وصل کن
    console.log('[telemetry]', event, props ?? {});
  }
}

// ======================================================
// FILE: src/app/core/utils/backoff.ts
// ======================================================
import { Observable, timer } from 'rxjs';
import { delayWhen, scan, tap } from 'rxjs/operators';

export const backoff =
  (maxRetries = 5, baseMs = 500) =>
  <T>(errors: Observable<T>) =>
    errors.pipe(
      scan((i) => i + 1, 0),
      tap((i) => {
        if (i >= maxRetries) throw new Error('max retries exceeded');
      }),
      delayWhen((i) => timer(baseMs * Math.pow(2, i)))
    );

// ======================================================
// FILE: src/app/features/files/files.routes.ts
// ======================================================
import { Routes } from '@angular/router';

export const FILES_ROUTES: Routes = [
  {
    path: '',
    loadComponent: () =>
      import('./ui/files-list.page').then((m) => m.FilesListPage),
  },
  {
    path: ':id',
    loadComponent: () =>
      import('./ui/file-detail.page').then((m) => m.FileDetailPage),
  },
];

// ======================================================
// FILE: src/app/features/files/ui/files-list.page.ts
// ======================================================
import { Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink } from '@angular/router';
import { UploadQueueStore } from '../data-access/upload-queue.store';
import { ResumableUploadService } from '../data-access/resumable-upload.service';
import { Telemetry } from '../../../core/obs/telemetry.service';

@Component({
  standalone: true,
  imports: [CommonModule, RouterLink],
  template: `
    <h2>Your Files</h2>

    <label class="picker">
      <input type="file" (change)="pick($event)" />
      <span>Choose a file to upload</span>
    </label>

    <section *ngIf="(queue.tasks$ | async) as tasks">
      <h3>Uploads</h3>
      <ul>
        <li *ngFor="let t of tasks">
          <strong>{{ t.fileName }}</strong>
          — {{ t.progress }}% — <em>{{ t.status }}</em>
          <button (click)="cancel(t.id)" [disabled]="t.status!=='uploading'">
            Cancel
          </button>
          <a *ngIf="t.status === 'done'" [routerLink]="['/files', t.id]">
            Open
          </a>
        </li>
      </ul>
    </section>
  `,
  styles: [
    `
      .picker {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.75rem 1rem;
        border: 1px dashed #999;
        border-radius: 10px;
        cursor: pointer;
        user-select: none;
      }
      .picker input {
        display: none;
      }
      ul {
        padding-left: 1rem;
      }
      li {
        margin: 0.25rem 0;
      }
      button {
        margin-left: 0.5rem;
      }
    `,
  ],
})
export class FilesListPage {
  private queue = inject(UploadQueueStore);
  private upload = inject(ResumableUploadService);
  private tel = inject(Telemetry);

  pick(ev: Event) {
    const f = (ev.target as HTMLInputElement).files?.[0];
    if (!f) return;

    const id = crypto.randomUUID();
    this.queue.upsert({
      id,
      fileName: f.name,
      size: f.size,
      progress: 0,
      status: 'queued',
    });

    const task = this.upload.upload(f);
    this.tel.track('upload_started', { id, name: f.name, size: f.size });

    const sub1 = task.progress$.subscribe((p) =>
      this.queue.upsert({
        id,
        fileName: f.name,
        size: f.size,
        progress: p,
        status: p < 100 ? 'uploading' : 'done',
      })
    );

    const sub2 = task.done$.subscribe({
      next: () => {
        this.queue.upsert({
          id,
          fileName: f.name,
          size: f.size,
          progress: 100,
          status: 'done',
        });
        this.tel.track('upload_done', { id });
      },
      error: () => {
        this.queue.upsert({
          id,
          fileName: f.name,
          size: f.size,
          progress: 0,
          status: 'error',
        });
        this.tel.track('upload_error', { id });
      },
      complete: () => {
        sub1.unsubscribe();
        sub2.unsubscribe();
      },
    });

    // نگه‌داشتن مرجع برای لغو
    this.queue.bindAbort(id, task.cancel);
  }

  cancel(id: string) {
    this.queue.cancel(id);
    this.tel.track('upload_canceled', { id });
  }

  // خروجی برای قالب
  public get queue$() {
    return this.queue.tasks$;
  }
}

// ======================================================
// FILE: src/app/features/files/ui/file-detail.page.ts
// ======================================================
import { Component, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, RouterLink } from '@angular/router';

@Component({
  standalone: true,
  imports: [CommonModule, RouterLink],
  template: `
    <a routerLink="/files">Back</a>
    <h2>File Detail</h2>
    <p>File id: <strong>{{ id }}</strong></p>
    <!-- این صفحه بعداً نسخه‌ها/اشتراک‌گذاری را نشان می‌دهد -->
  `,
})
export class FileDetailPage {
  id = inject(ActivatedRoute).snapshot.paramMap.get('id');
}

// ======================================================
// FILE: src/app/features/files/data-access/resumable-upload.service.ts
// ======================================================
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Subject, from, Observable } from 'rxjs';
import { concatMap, map, finalize, retryWhen } from 'rxjs/operators';
import { backoff } from '../../../core/utils/backoff';

@Injectable({ providedIn: 'root' })
export class ResumableUploadService {
  private http = inject(HttpClient);

  /**
   * آپلود قطعه‌ای با قابلیت لغو + backoff
   * سرور باید قطعات را با هدرهای X-Chunk-* مونتاژ کند.
   */
  upload(
    file: File,
    chunkSize = 1024 * 1024
  ): { progress$: Observable<number>; done$: Observable<string>; cancel: () => void } {
    const chunks = Math.ceil(file.size / chunkSize);
    const abort = new AbortController();
    const progress = new Subject<number>();
    const done = new Subject<string>();

    from([...Array(chunks).keys()])
      .pipe(
        concatMap((i) => {
          const start = i * chunkSize;
          const end = Math.min(file.size, start + chunkSize);
          const body = file.slice(start, end);
          const headers = {
            'X-Chunk-Index': String(i),
            'X-Total-Chunks': String(chunks),
            'X-File-Name': encodeURIComponent(file.name),
          };
          return this.http
            .post<{ uploadId: string }>('/api/uploads', body, {
              headers,
              signal: abort.signal,
            })
            .pipe(retryWhen(backoff(4, 400)));
        }, 1),
        map((_res, i) => Math.round(((i + 1) / chunks) * 100)),
        finalize(() => {
          progress.complete();
          done.complete();
        })
      )
      .subscribe({
        next: (p) => progress.next(p),
        error: (e) => {
          progress.error(e);
          done.error(e);
        },
        complete: () => {
          done.next('ok');
        },
      });

    return {
      progress$: progress.asObservable(),
      done$: done.asObservable(),
      cancel: () => abort.abort(),
    };
  }
}

// ======================================================
// FILE: src/app/features/files/data-access/upload-queue.store.ts
// (State Management ساده + Persist در IndexedDB)
// ======================================================
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { get, set } from 'idb-keyval';

export interface UploadTask {
  id: string;
  fileName: string;
  size: number;
  progress: number;
  status: 'queued' | 'uploading' | 'done' | 'error' | 'canceled';
}

@Injectable({ providedIn: 'root' })
export class UploadQueueStore {
  private _tasks = new BehaviorSubject<UploadTask[]>([]);
  private abortMap = new Map<string, () => void>();

  tasks$ = this._tasks.asObservable();

  constructor() {
    this.hydrate();
  }

  async hydrate() {
    const saved = ((await get('uploadQueue')) as UploadTask[]) ?? [];
    this._tasks.next(saved);
  }

  private save(tasks: UploadTask[]) {
    set('uploadQueue', tasks);
  }

  upsert(t: UploadTask) {
    const tasks = [...this._tasks.value];
    const i = tasks.findIndex((x) => x.id === t.id);
    if (i === -1) tasks.push(t);
    else tasks[i] = { ...tasks[i], ...t };
    this._tasks.next(tasks);
    this.save(tasks);
  }

  bindAbort(id: string, abort: () => void) {
    this.abortMap.set(id, abort);
  }

  cancel(id: string) {
    this.abortMap.get(id)?.();
    this.abortMap.delete(id);
    this.upsert({ id, fileName: '', size: 0, progress: 0, status: 'canceled' } as UploadTask);
  }

  clear(id: string) {
    const left = this._tasks.value.filter((t) => t.id !== id);
    this._tasks.next(left);
    this.save(left);
  }
}

// ======================================================
// FILE: src/app/shared/not-found.page.ts
// ======================================================
import { Component } from '@angular/core';

@Component({
  standalone: true,
  template: `<h2>Not Found</h2><p>The page you are looking for does not exist.</p>`,
})
export class NotFoundPage {}





نکات اجرا
یک سرور بک‌اند لازم است که endpoint POST /api/uploads را برای دریافت قطعات پشتیبانی کند (بر اساس هدرهای X-Chunk-Index, X-Total-Chunks, X-File-Name قطعات را مونتاژ کند). اگر از TUS یا Content-Range استفاده می‌کنی، می‌توانیم سرویس را مطابق آن تنظیم کنیم.

برای نصب وابستگی Persist:

css
Copy
Edit
npm i idb-keyval
اگر دوست داری، مرحلهٔ اشتراک‌گذاری فایل با لینک، نسخه‌ها و Auth (OIDC) را هم به همین اسکلت اضافه می‌کنم—فقط بگو سمت سرورت چی در نظر داری.
